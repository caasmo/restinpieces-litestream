# restinpieces-litestream

This repository provides a Litestream integration module for the [restinpieces](https://github.com/caasmo/restinpieces) framework. It allows you to easily add continuous backup capabilities for your application's SQLite database(s) using Litestream.

## Configuration

This module now uses the standard `litestream.yml` configuration format. Litestream configuration is managed securely through the restinpieces `SecureConfigStore`.

1.  **Create a `litestream.yml` file:** Create a standard Litestream configuration file. You can find examples in the [official Litestream documentation](https://litestream.io/config/). You can configure replicas for one or more databases, including using directory monitoring.

2.  **Encrypt and Store:** Use the `insert-config` tool provided by the [restinpieces](https://github.com/caasmo/restinpieces) framework to encrypt the YAML file using your age key and store it in the database. Use the scope defined by `litestream.ConfigScope` (default: "litestream").
    ```bash
    # Assuming insert-config is built and in your PATH
    # and restinpieces is in your GOPATH
    go build -o bin/insert-config ../restinpieces/cmd/insert-config
    ./bin/insert-config \
      -age-key /path/to/your/age.key \
      -db /path/to/your/app.db \
      -file /path/to/your/litestream.yml \
      -scope litestream \
      -format yaml \
      -desc "Initial Litestream configuration"
    ```

## Logging

The logging integration is designed as a pragmatic compromise to avoid maintaining a complex fork of the upstream Litestream library.

This module follows a **"split-logging"** model:

1.  **Framework Logs:** All logs generated by the `restinpieces-litestream` daemon wrapper itself are sent to the main framework's `slog.Logger` instance. If you are using the default `restinpieces` setup, these logs will be written to the SQLite database with full structured context.

2.  **Internal Litestream Logs:** All internal logs from the core Litestream components (e.g., relating to replication, snapshots, compaction) are sent to **`os.Stderr`**. This behavior mimics running Litestream as a separate binary alongside the main application.

### Configuring Internal Logs

While these internal logs are sent to a separate stream, you can still control their **format** and **level** via the `litestream.yml` configuration file. This is handled by a function from our Litestream fork that configures the library's internal global logger.

Example `litestream.yml` logging section:
```yaml
logging:
  # 'debug', 'info', 'warn', or 'error'
  level: 'debug' 
  # 'text' or 'json'
  type: 'json'
```
This configuration would cause the internal Litestream logs written to `os.Stderr` to be structured JSON at the `DEBUG` level, while the main framework logs continue to go to their own destination.

## Integration Example

Refer to [cmd/example/main.go](./cmd/example/main.go) to see how to:
*   Initialize the `restinpieces.Server`.
*   Load the Litestream YAML configuration from the secure store.
*   Instantiate the `litestream.Litestream` service.
*   Add it as a daemon to the `restinpieces.Server`.

## Driver Compatibility (CGO vs Pure-Go)

**Important:** The underlying [Litestream library](https://github.com/benbjohnson/litestream) internally uses the [mattn/go-sqlite3](https://github.com/mattn/go-sqlite3) driver, which relies on CGO. This is a dependency of Litestream itself.

**Using Pure-Go Drivers:**
You **can** use this `restinpieces-litestream` module even if your main application uses a pure-Go SQLite driver for its database operations, such as:
*   [zombiezen.com/go/sqlite](https://zombiezen.com/go/sqlite) (the default in `restinpieces`)
*   [modernc.org/sqlite](https://modernc.org/sqlite)

The CGO dependency of Litestream does not conflict with pure-Go drivers used by the rest of your application.

**Using Other CGO Drivers:**
You will encounter compilation errors if your main application attempts to use a *different* CGO-based SQLite driver simultaneously, such as [crawshaw.io/sqlite](https://crawshaw.io/sqlite). This is because Go does not permit linking multiple different CGO implementations of SQLite within the same binary.

The `restinpieces` framework provides a separate database implementation for the Crawshaw driver here: [caasmo/restinpieces-sqlite-crawshaw](https://github.com/caasmo/restinpieces-sqlite-crawshaw). However, you cannot use it in the same application build as this Litestream module.

**In summary:** This module works fine with pure-Go SQLite drivers but conflicts with other CGO-based SQLite drivers like Crawshaw's.

## SQLite PRAGMAs for Litestream

Consider setting the following PRAGMAs in your application when initializing the database connection for optimal performance and compatibility with Litestream:

https://litestream.io/tips/

Disable autocheckpoints for high write load servers.  Prevent aplication to do
checkpoints:

    PRAGMA wal_autocheckpoint = 0;

This mode will ensure that the fsync() calls are only called when the WAL
becomes full and has to checkpoint to the main database file. This is safe as
the WAL file is append only. Should be probably default when using WAL:

    PRAGMA synchronous = NORMAL;

Litestream requires periodic but short write locks on the database when
checkpointing occurs. SQLite will return an error by default if your
application tries to obtain a write lock at the same time.
This pragma will wait up to a given number of milliseconds before failing a
query if it is blocked on a write.

    PRAGMA busy_timeout = 5000;