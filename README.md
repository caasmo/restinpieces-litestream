# restinpieces-litestream

This package allows you to use Litestream's continuous backup capabilities "in-process" with your [restinpieces](https://github.com/caasmo/restinpieces) application. It removes the need to manage a separate Litestream binary, systemd service, and standalone configuration files.

Instead, it provides a `restinpieces` daemon that is compiled into your application binary and integrates directly with the framework's lifecycle and secure configuration store.

## Configuration

This module uses the standard `litestream.yml` configuration format. Litestream configuration is managed securely through the restinpieces `SecureConfigStore`, which is managed with the `ripc` command-line tool.

1.  **Create a `litestream.yml` file:** Create a standard Litestream configuration file. You can find examples and a full reference in the [official Litestream configuration documentation](https://litestream.io/reference/config/).

2.  **Encrypt and Store with `ripc`:** For simplicity and security, the `restinpieces` framework encrypts and stores all configuration directly within the main application SQLite database. Use the `ripc config save` command to perform this action for your Litestream configuration. The scope must be `litestream`, as defined by `litestream.ConfigScope`.

    ```bash
    ripc -age-key /path/to/your/age.key -dbpath /path/to/your/app.db config save -scope litestream /path/to/your/litestream.yml
    ```
    For more information on `ripc`, see the [`ripc` documentation](https://github.com/caasmo/restinpieces/blob/master/doc/ripc.md).

## Logging

The upstream Litestream project is designed primarily as a standalone binary. This architecture makes it difficult to cleanly inject a custom `slog.Logger` when using Litestream as an embedded library, as its internal components fall back to a global default logger.

To solve this without requiring a heavily modified and hard-to-maintain fork, this module uses a "split-logging" model. Our compromise is to expose Litestream's own logging configuration, allowing us to control its output separately from the main framework logger.

This module follows a **"split-logging"** model:

1.  **Framework Logs:** All logs generated by the `restinpieces-litestream` daemon wrapper itself are sent to the main framework's `slog.Logger` instance. If you are using the default `restinpieces` setup, these logs will be written to the SQLite database with full structured context.

2.  **Internal Litestream Logs:** All internal logs from the core Litestream components (e.g., relating to replication, snapshots, compaction) are sent to either **`os.Stdout`** (the default) or **`os.Stderr`**. This behavior mimics running Litestream as a separate binary alongside the main application.

### Configuring Internal Logs

The destination, format, and level of these internal logs can be controlled via the `litestream.yml` configuration file. This is handled by a function from our Litestream fork that configures the library's internal global logger.

Example `litestream.yml` logging section:
```yaml
logging:
  # 'debug', 'info', 'warn', or 'error'
  level: 'info' 
  # 'text' or 'json'
  type: 'text'
  # Direct logs to stderr instead of stdout. Defaults to false.
  stderr: false
```
This configuration would cause the internal Litestream logs to be written to `os.Stdout` as text at the `INFO` level, while the main framework logs continue to go to their own destination.

## Integration Example

Refer to [cmd/example/main.go](./cmd/example/main.go) to see how to:
*   Initialize the `restinpieces.Server`.
*   Load the Litestream YAML configuration from the secure store.
*   Instantiate the `litestream.Litestream` service.
*   Add it as a daemon to the `restinpieces.Server`.

## Driver Compatibility

As of v0.5.0, the underlying [Litestream library](https://github.com/benbjohnson/litestream) uses the excellent [modernc.org/sqlite](https://modernc.org/sqlite) driver, which is **pure-Go**.

This is a major advantage as it means this module has **no CGO dependency**.
*   No C compiler or external dependencies are needed to build your application.
*   Cross-compilation is simple.
*   There are no conflicts with any other SQLite drivers (whether pure-Go or CGO-based) that your main application might use.

This aligns perfectly with the `restinpieces` framework, whose default database driver is [zombiezen.com/go/sqlite](https://zombiezen.com/go/sqlite), which is also a pure-Go driver. This ensures a CGO-free environment when using the default settings for both the framework and this module.

## SQLite PRAGMAs for Litestream

Consider setting the following PRAGMAs in your application when initializing the database connection for optimal performance and compatibility with Litestream:

https://litestream.io/tips/

Disable autocheckpoints for high write load servers.  Prevent aplication to do
checkpoints:

    PRAGMA wal_autocheckpoint = 0;

This mode will ensure that the fsync() calls are only called when the WAL
becomes full and has to checkpoint to the main database file. This is safe as
the WAL file is append only. Should be probably default when using WAL:

    PRAGMA synchronous = NORMAL;

Litestream requires periodic but short write locks on the database when
checkpointing occurs. SQLite will return an error by default if your
application tries to obtain a write lock at the same time.
This pragma will wait up to a given number of milliseconds before failing a
query if it is blocked on a write.

    PRAGMA busy_timeout = 5000;
